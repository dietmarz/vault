include::{root}/.inc/include.adoc[]

= Kotlin

* x = (<exp1> ?: <exp2>) Elvis-Operator: exp1 == null ? <exp1> : <exp2>
* use `?.let{...}` instead of if not null
* `with(obj) {member="value"}` spart Schreibarbeit, return Lambda-Ausdruck
* `obj.run {member="value"}` is the same as with aber mit . angewendet, return Lambda-Ausdruck
* `obj.let {it.member="value"}` durch `it` mehr Klarheit wer gemeint ist, return Lambda-Ausdruck
* `obj.apply {member="value"}` returns this
* `obj.also {it.member="value"}`  returns this, gut in einer Aufrufkette oder zum tauschen

* `apply` offers invisible this and returns this

* zahl.`takeIf` { it> minimum }?.let { ... }

[source, kotlin]
----
val result = service.call()?.let {
    println(it)
    it.length  // Der Rückgabewert des Blocks
}
----

== Infix function
* Call function, omitting dot and parenthesis, like an operator <<diving>>
* must be member or extension functions
* must have a single parameter, no varargs

== data class
* equals, hashCode, toString, copy
* component-N-() N = Position in der Parameterliste des Primärkonstruktors

[source, kotlin]
----
data class User(val name: String, val age: Int)
val user1 = User("Alice", 30) // Construct
println(user1)  // toString: Gibt "User(name=Alice, age=30)" aus
val user2 = User("Alice", 30)
println(user1 == user2)  // equals: Gibt "true" aus, weil die Inhalte gleich sind
val user3 = user1.copy(age = 31)
println(user3)  // Copy: Gibt "User(name=Alice, age=31)" aus
val user3 = user1.copy(age = 31)
println(user3)  // Destructing Gibt "User(name=Alice, age=31)" aus
----

== Operators
[source, kotlin]
----
operator fun MyClass.plus(other: MyClass): MyClass {return MyClass(...)}
// + plus, - minus, ++ incr, -- decr, [N] get, contains, in, invoke, compareTo, rangeTo

----


== Higher funktions
* inline means some kind of copy that method
* Returns from lambda or from outer funktion? Return always returns from the closest `fun` keyword
.Lambda-Ausdruck GPT

[source,kotlin]
----
val greet = { println("Hello, World!") }
greet()
val printMessage = { message: String -> println(message) }
printMessage("Hello, Kotlin!")  // Ruft den Lambda-Ausdruck auf und druckt "Hello, Kotlin!"


fun doSomething1(param1: Int, action: (msg: String) -> Unit) {
    action(msg)

} // Lambda ist letztes Argument, dann darf "Trailing Lambda"
doSomething(5) {msg -> print("Hallo $msg")}
// Mit Parametern ---------------------------------------------------------------------
fun repeatAction(times: Int, action: (Int) -> Unit) {
    for (i in 0 until times) {
        action(i)
    }
}
repeatAction(3) { index ->
    println("Action $index")
}
----



== Klassen und Objekte
* Innere Klassen sind erstmal statisch, es sein denn sie sind it `inner class` deklariert. <<hb>> 232




[bibliography]
- [[[diving]]] https://www.youtube.com/watch?v=zmqhe7fDEHI[Diving 2020]
  Diving into advanced Kotlin features by Simon Wirtz
- [[[hb]]] {doc}/java/kotlin/Kotlin-Das-umfassende-Handbuch.pdf
file:///home/dietmar/cloud/doc/java/kotlin/Kotlin-Das-umfassende-Handbuch.pdf