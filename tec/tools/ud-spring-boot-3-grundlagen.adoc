include::{root}/.inc/include.adoc[]

= SpringBoot 3

* https://www.udemy.com/course/spring-boot-3-spring-framework-6-grundlagen/[udemy]
* https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/[Ref-doku]

* Spring-boot starter enthalten die Minimalkonfiguration

== 1.8  Dependencies eines Spring Boot Projektes; POM, BOM
.Eigene parent POM dazwischen hängen
----
dependencyManagement.dependencies.dependency ->
  groupId: org.springframework.boot, artifactId: spring-boot-dependencies, version: xyz, type: pom, scope: import
----
Zu beachten ist das man einige Konfigurationen wiederholen muss.-

* 2.18 Optionale Abhängigkeiten:
  ** Mit `@Autowired(required=false)`, setter werden nicht aufgerufen,
  ** bei `@Nullable` wird der Setter mit null aufgerufen
  ** `Optional<>` bei null ist es empty. Sehr elegant aber Optional ist nicht serialisierbar!
  ** `ObjectProvider`
* 2.18 Zyklische Abhängigkeiten lösen:
  ** spring.main.allow-circular-references=true # No!
  ** Setter nutzen. # Merkwürdig...
  ** `@Lazy-Annotation` bei `@Autowired` einsetzen
* 2.19 Klasse mit @Configuration und eine @Bean methode schreiben. dann volle Freiheit. Methodenname == Beanname

.2.19
----
@Bean String appUuid1() { ... randomUuid() }
@Bean String appUuid2() { return appUuid() }

appUuid2 returned dieselbe Uuid, obwohl es ein direkter Aufruf ist, da sich Spring per CGLIB dazwischen hängt. Wenn man das nicht möchte
kann man den proxy mechanismus abschalten mit `@Configuration(proxyBeanMethods = false)`
----
* In Spring nicht mit get etwas aktiv holen, sondern sich injizieren lassen. IoC